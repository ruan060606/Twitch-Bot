{"version":3,"sources":["../../src/Chat/Client.js"],"names":["constants","validators","utils","priority","CLIENT_PRIORITY","Client","maybeOptions","options","clientOptions","protocol","ssl","ws","server","port","onopen","handleOpen","bind","onmessage","handleMessage","onerror","handleError","onclose","handleClose","queue","readyState","send","disconnect","message","weighProps","fn","push","weight","getMessageQueueWeight","close","oauth","username","messageEvent","rawMessage","data","messages","forEach","command","COMMANDS","PING","GLOBAL_USER_STATE","emit","EVENTS","CONNECTED","ALL","error","_raw","timestamp","Date","event","PARSE_ERROR_ENCOUNTERED","Error","RAW","ERROR_ENCOUNTERED","DISCONNECTED"],"mappings":";;;;;;;;;;AAAA;;AACA;;;;AAEA;;IAAYA,S;;AACZ;;;;AACA;;IAAYC,U;;AACZ;;IAAYC,K;;AAEZ;;;;;;;;;;;;;;;;AAEA,IAAMC,WAAWH,UAAUI,eAA3B;;IAEMC,M;;;AAGJ,oBAA+B;AAAA,QAAnBC,YAAmB,uEAAJ,EAAI;;AAAA;;AAG7B;AAH6B;;AAI7B,QAAMC,UAAUN,WAAWO,aAAX,CAAyBF,YAAzB,CAAhB;;AAEA;AACA,QAAMG,WAAWF,QAAQG,GAAR,GAAc,KAAd,GAAsB,IAAvC;AACA,QAAMC,KAAK,kBAAiBF,QAAjB,WAA+BF,QAAQK,MAAvC,SAAiDL,QAAQM,IAAzD,CAAX;;AAEAF,OAAGG,MAAH,GAAYC,WAAWC,IAAX,QAAsBT,OAAtB,CAAZ;AACAI,OAAGM,SAAH,GAAeC,cAAcF,IAAd,OAAf;AACAL,OAAGQ,OAAH,GAAaC,YAAYJ,IAAZ,OAAb;AACAL,OAAGU,OAAH,GAAaC,YAAYN,IAAZ,OAAb;;AAEA;AACA,QAAMO,QAAQ,qBAAd;;AAEA,UAAKC,UAAL,GAAkBb,GAAGa,UAArB;AACA,UAAKC,IAAL,GAAY,MAAKA,IAAL,CAAUT,IAAV,CAAe,EAAEL,MAAF,EAAMY,YAAN,EAAf,CAAZ;AACA,UAAKG,UAAL,GAAkB,MAAKA,UAAL,CAAgBV,IAAhB,CAAqB,EAAEL,MAAF,EAArB,CAAlB;AApB6B;AAqB9B;;AAED;;;;;;;;;;;yBAOKgB,O,EAA2C;AAAA,qFAAJ,EAAI;;AAAA,UAAhCxB,QAAgC,QAAhCA,QAAgC;AAAA,UAAnByB,UAAmB;;AAC9C,UAAMC,KAAK,KAAKlB,EAAL,CAAQc,IAAR,CAAaT,IAAb,CAAkB,KAAKL,EAAvB,EAA2BgB,OAA3B,CAAX;;AAEA,WAAKJ,KAAL,CAAWO,IAAX,CAAgB;AACdD,cADc;AAEd1B,0BAFc;AAGd4B,gBAAQ7B,MAAM8B,qBAAN,CAA4BJ,UAA5B;AAHM,OAAhB;AAKD;;;iCAEY;AACX,WAAKjB,EAAL,CAAQsB,KAAR;AACD;;;;;;AAGH,SAASlB,UAAT,CAAoBR,OAApB,EAA6B;AAC3B;AACA,OAAKkB,IAAL,CAAU,iEAAV,EAA6E;AAC3EtB;AAD2E,GAA7E;;AAIA;AACA,OAAKsB,IAAL,WAAkBlB,QAAQ2B,KAA1B,EAAmC,EAAE/B,kBAAF,EAAnC;AACA,OAAKsB,IAAL,WAAkBlB,QAAQ4B,QAA1B,EAAsC,EAAEhC,kBAAF,EAAtC;AACD;;AAED,SAASe,aAAT,CAAuBkB,YAAvB,EAAqC;AAAA;;AACnC;AACA,MAAMC,aAAaD,aAAaE,IAAhC;;AAEA,MAAI;AACF,QAAMC,WAAW,uBAAWF,UAAX,CAAjB;;AAEAE,aAASC,OAAT,CAAiB,mBAAW;AAC1B;AACA,UAAIb,QAAQc,OAAR,KAAoBzC,UAAU0C,QAAV,CAAmBC,IAA3C,EAAiD;AAC/C,eAAKlB,IAAL,CAAU,qBAAV,EAAiC,EAAEtB,kBAAF,EAAjC;AACD;;AAED;AACA,UAAIwB,QAAQc,OAAR,KAAoBzC,UAAU0C,QAAV,CAAmBE,iBAA3C,EAA8D;AAC5D,eAAKC,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBC,SAA3B,eACKpB,OADL;AAEEc,mBAASzC,UAAU8C,MAAV,CAAiBC;AAF5B;AAID;;AAED;AACA,aAAKF,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBE,GAA3B,EAAgCrB,OAAhC;AACD,KAhBD;AAiBD,GApBD,CAoBE,OAAOsB,KAAP,EAAc;AACd,QAAMtB,UAAU;AACduB,YAAMb,UADQ;AAEdc,iBAAW,IAAIC,IAAJ,EAFG;AAGdC,aAAOrD,UAAU8C,MAAV,CAAiBQ,uBAHV;AAId3B,eAASsB;AAJK,KAAhB;;AAOA,SAAKJ,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBQ,uBAA3B,EAAoD3B,OAApD;;AAEA,UAAM,IAAI4B,KAAJ,CAAUN,KAAV,CAAN;AACD,GA/BD,SA+BU;AACR,QAAMtB,WAAU;AACduB,YAAMb,UADQ;AAEdc,iBAAW,IAAIC,IAAJ,EAFG;AAGdC,aAAOrD,UAAU8C,MAAV,CAAiBU;AAHV,KAAhB;;AAMA,SAAKX,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBU,GAA3B,EAAgC7B,QAAhC;AACD;AACF;;AAED,SAASP,WAAT,CAAqB6B,KAArB,EAA4B;AAC1B,MAAMtB,UAAU;AACdwB,eAAW,IAAIC,IAAJ,EADG;AAEdC,WAAOrD,UAAU8C,MAAV,CAAiBW,iBAFV;AAGd9B,aAASsB;AAHK,GAAhB;;AAMA,OAAKJ,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBE,GAA3B,EAAgCrB,OAAhC;AACA,OAAKkB,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBW,iBAA3B,EAA8C9B,OAA9C;AACD;;AAED,SAASL,WAAT,GAAuB;AACrB,MAAMK,UAAU;AACdwB,eAAW,IAAIC,IAAJ,EADG;AAEdC,WAAOrD,UAAU8C,MAAV,CAAiBY;AAFV,GAAhB;;AAKA,OAAKb,IAAL,CAAU7C,UAAU8C,MAAV,CAAiBY,YAA3B,EAAyC/B,OAAzC;AACD;;kBAEctB,M","file":"Client.js","sourcesContent":["import { EventEmitter } from 'eventemitter3'\nimport WebSocket from '../../shims/uws'\n\nimport * as constants from './constants'\nimport baseParser from './utils/parsers'\nimport * as validators from './utils/validators'\nimport * as utils from './utils'\n\nimport Queue from './Queue'\n\nconst priority = constants.CLIENT_PRIORITY\n\nclass Client extends EventEmitter {\n  readyState\n\n  constructor(maybeOptions = {}) {\n    super()\n\n    // Validate options.\n    const options = validators.clientOptions(maybeOptions)\n\n    // Instantiate WebSocket.\n    const protocol = options.ssl ? 'wss' : 'ws'\n    const ws = new WebSocket(`${protocol}://${options.server}:${options.port}`)\n\n    ws.onopen = handleOpen.bind(this, options)\n    ws.onmessage = handleMessage.bind(this)\n    ws.onerror = handleError.bind(this)\n    ws.onclose = handleClose.bind(this)\n\n    // Instantiate Queue.\n    const queue = new Queue()\n\n    this.readyState = ws.readyState\n    this.send = this.send.bind({ ws, queue })\n    this.disconnect = this.disconnect.bind({ ws })\n  }\n\n  /**\n   * Send message to Twitch\n   * @param {string} message\n   * @param {Object} options\n   * @param {number} options.priority\n   * @param {MessageWeightProps} ...options.weighProps\n   */\n  send(message, { priority, ...weighProps } = {}) {\n    const fn = this.ws.send.bind(this.ws, message)\n\n    this.queue.push({\n      fn,\n      priority,\n      weight: utils.getMessageQueueWeight(weighProps),\n    })\n  }\n\n  disconnect() {\n    this.ws.close()\n  }\n}\n\nfunction handleOpen(options) {\n  // Register for Twitch-specific capabilities.\n  this.send('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership', {\n    priority,\n  })\n\n  // Authenticate.\n  this.send(`PASS ${options.oauth}`, { priority })\n  this.send(`NICK ${options.username}`, { priority })\n}\n\nfunction handleMessage(messageEvent) {\n  // console.log(messageEvent.data)\n  const rawMessage = messageEvent.data\n\n  try {\n    const messages = baseParser(rawMessage)\n\n    messages.forEach(message => {\n      // Handle PING/PONG.\n      if (message.command === constants.COMMANDS.PING) {\n        this.send('PONG :tmi.twitch.tv', { priority })\n      }\n\n      // Handle successful connections.\n      if (message.command === constants.COMMANDS.GLOBAL_USER_STATE) {\n        this.emit(constants.EVENTS.CONNECTED, {\n          ...message,\n          command: constants.EVENTS.CONNECTED,\n        })\n      }\n\n      // Emit all messages.\n      this.emit(constants.EVENTS.ALL, message)\n    })\n  } catch (error) {\n    const message = {\n      _raw: rawMessage,\n      timestamp: new Date(),\n      event: constants.EVENTS.PARSE_ERROR_ENCOUNTERED,\n      message: error,\n    }\n\n    this.emit(constants.EVENTS.PARSE_ERROR_ENCOUNTERED, message)\n\n    throw new Error(error)\n  } finally {\n    const message = {\n      _raw: rawMessage,\n      timestamp: new Date(),\n      event: constants.EVENTS.RAW,\n    }\n\n    this.emit(constants.EVENTS.RAW, message)\n  }\n}\n\nfunction handleError(error) {\n  const message = {\n    timestamp: new Date(),\n    event: constants.EVENTS.ERROR_ENCOUNTERED,\n    message: error,\n  }\n\n  this.emit(constants.EVENTS.ALL, message)\n  this.emit(constants.EVENTS.ERROR_ENCOUNTERED, message)\n}\n\nfunction handleClose() {\n  const message = {\n    timestamp: new Date(),\n    event: constants.EVENTS.DISCONNECTED,\n  }\n\n  this.emit(constants.EVENTS.DISCONNECTED, message)\n}\n\nexport default Client\n"]}