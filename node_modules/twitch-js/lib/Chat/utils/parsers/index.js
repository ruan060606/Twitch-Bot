'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.privateMessage = exports.userNoticeMessage = exports.noticeMessage = exports.roomStateMessage = exports.userStateMessage = exports.globalUserStateMessage = exports.clearChatMessage = exports.namesEndMessage = exports.namesMessage = exports.joinOrPartMessage = exports.hostTargetMessage = exports.modeMessage = undefined;

var _toUpper2 = require('lodash/toUpper');

var _toUpper3 = _interopRequireDefault(_toUpper2);

var _toNumber2 = require('lodash/toNumber');

var _toNumber3 = _interopRequireDefault(_toNumber2);

var _isFinite2 = require('lodash/isFinite');

var _isFinite3 = _interopRequireDefault(_isFinite2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _ircMessage = require('irc-message');

var _camelcaseKeys = require('camelcase-keys');

var _camelcaseKeys2 = _interopRequireDefault(_camelcaseKeys);

var _constants = require('../../constants');

var constants = _interopRequireWildcard(_constants);

var _types = require('./types');

var typeParsers = _interopRequireWildcard(_types);

var _tags = require('./tags');

var tagParsers = _interopRequireWildcard(_tags);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var base = function base(rawMessages) {
  var rawMessagesV = rawMessages.replace(/\r\n$/, '').split(/\n/g);

  return rawMessagesV.map(function (rawMessage) {
    var _parse = (0, _ircMessage.parse)(rawMessage),
        raw = _parse.raw,
        tags = _parse.tags,
        command = _parse.command,
        _parse$params = _slicedToArray(_parse.params, 2),
        channel = _parse$params[0],
        message = _parse$params[1];

    /**
     * Base message parsed from Twitch
     * @mixin BaseMessage
     * @property {string} _raw Un-parsed message
     * @property {Date} timestamp Timestamp
     * @property {string} command Command
     * @property {(ClearChatTags|GlobalUserStateTags|PrivateMessageTags|RoomStateTags|UserNoticeTags|UserStateTags)} tags Twitch tags
     * @property {string} [channel] Channel
     * @property {string} [message] Message
     * @property {string} [event] Associated event
     */


    return {
      _raw: raw,
      timestamp: typeParsers.generalTimestamp(parseInt(tags['tmi-sent-ts'], 10)),
      command: command,
      channel: channel,
      tags: (0, _isEmpty3.default)(tags) ? undefined : (0, _camelcaseKeys2.default)(tags),
      message: message
    };
  });
};

var joinOrPartMessage = function joinOrPartMessage(baseMessage) {
  var _$exec = /:(.+)!(.+)@(.+).tmi.twitch.tv (JOIN|PART) (#.+)/g.exec(baseMessage._raw),
      _$exec2 = _slicedToArray(_$exec, 6),
      username = _$exec2[1],
      command = _$exec2[4],
      channel = _$exec2[5];

  /**
   * Join a channel.
   * @event Chat#JOIN
   * @mixes BaseMessage JoinOrPartMessage
   * @property {string} username Username (lower-case)
   * @see https://dev.twitch.tv/docs/irc/membership/#join-twitch-membership
   */
  /**
   * Depart from a channel.
   * @event Chat#PART
   * @mixes BaseMessage JoinOrPartMessage
   * @property {string} username Username (lower-case)
   * @see https://dev.twitch.tv/docs/irc/membership/#part-twitch-membership
   */


  return _extends({}, baseMessage, {
    channel: channel,
    command: command,
    username: username,
    message: undefined
  });
};

var modeMessage = function modeMessage(baseMessage) {
  var _$exec3 = /:[^\s]+ MODE (#[^\s]+) (-|\+)o ([^\s]+)/g.exec(baseMessage._raw),
      _$exec4 = _slicedToArray(_$exec3, 4),
      channel = _$exec4[1],
      mode = _$exec4[2],
      username = _$exec4[3];

  var isModerator = mode === '+';

  /**
   * Gain/lose moderator (operator) status in a channel.
   * @event Chat#MODE
   * @mixes BaseMessage ModeMessage
   * @property {string} event
   * @property {string} username
   * @property {boolean} isModerator
   * @see https://dev.twitch.tv/docs/irc/membership/#mode-twitch-membership
   */
  return _extends({}, baseMessage, {
    event: isModerator ? constants.EVENTS.MOD_GAINED : constants.EVENTS.MOD_LOST,
    channel: channel,
    username: username,
    message: undefined,
    isModerator: isModerator
  });
};

var namesMessage = function namesMessage(baseMessage) {
  var _$exec5 = /:(.+).tmi.twitch.tv 353 (.+) = (#.+) :(.+)/g.exec(baseMessage._raw),
      _$exec6 = _slicedToArray(_$exec5, 5),
      channel = _$exec6[3],
      names = _$exec6[4];

  var namesV = names.split(' ');

  /**
   * List current chatters in a channel.
   * @event Chat#NAMES
   * @mixes BaseMessage NamesMessage
   * @property {Array<string>} usernames Array of usernames present in channel
   * @property {('mods'|'chatters')} listType
   * @see https://dev.twitch.tv/docs/irc/membership/#names-twitch-membership
   */
  return _extends({}, baseMessage, {
    channel: channel,
    event: constants.EVENTS.NAMES,
    usernames: namesV,
    listType: names.length > 1000 ? 'mods' : 'chatters',
    message: undefined
  });
};

var namesEndMessage = function namesEndMessage(baseMessage) {
  var _$exec7 = /:(.+).tmi.twitch.tv 366 (.+) (#.+) :(.+)/g.exec(baseMessage._raw),
      _$exec8 = _slicedToArray(_$exec7, 5),
      username = _$exec8[1],
      channel = _$exec8[3],
      message = _$exec8[4];

  /**
   * End of list current chatters in a channel.
   * @event Chat#NAMES_END
   * @mixes BaseMessage NamesEndMessage
   * @see https://dev.twitch.tv/docs/irc/membership/#names-twitch-membership
   */


  return _extends({}, baseMessage, {
    channel: channel,
    event: constants.EVENTS.NAMES_END,
    username: username,
    message: message
  });
};

var globalUserStateMessage = function globalUserStateMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  /**
   * GLOBALUSERSTATE message
   * @mixin GlobalUserStateMessage
   * @mixes BaseMessage
   * @property {GlobalUserStateTags} tags
   */
  /**
   * On successful login.
   * @event Chat#GLOBALUSERSTATE
   * @mixes GlobalUserStateMessage
   */


  return _extends({
    tags: tagParsers.globalUserState(tags)
  }, other);
};

var clearChatMessage = function clearChatMessage(baseMessage) {
  var tags = baseMessage.tags,
      username = baseMessage.message,
      other = _objectWithoutProperties(baseMessage, ['tags', 'message']);

  if (typeof username !== 'undefined') {
    /**
     * Temporary or permanent ban on a channel.
     * @event Chat#CLEARCHAT/USER_BANNED
     * @mixes BaseMessage ClearChatUserBannedMessage
     * @property {ClearChatTags} tags
     * @property {string} username
     * @see https://dev.twitch.tv/docs/irc/commands/#clearchat-twitch-commands
     * @see https://dev.twitch.tv/docs/irc/tags/#clearchat-twitch-tags
     */
    return _extends({}, other, {
      tags: _extends({}, tags, {
        banReason: typeParsers.generalString(tags.banReason),
        banDuration: typeParsers.generalNumber(tags.banDuration)
      }),
      event: constants.EVENTS.USER_BANNED,
      username: username
    });
  }

  /**
   * All chat is cleared (deleted).
   * @event Chat#CLEARCHAT
   * @mixes BaseMessage ClearChatMessage
   * @see https://dev.twitch.tv/docs/irc/commands/#clearchat-twitch-commands
   * @see https://dev.twitch.tv/docs/irc/tags/#clearchat-twitch-tags
   */
  return _extends({}, other);
};

var hostTargetMessage = function hostTargetMessage(baseMessage) {
  var _$exec9 = /:tmi.twitch.tv HOSTTARGET (#[^\s]+) :([^\s]+)?\s?(\d+)?/g.exec(baseMessage._raw),
      _$exec10 = _slicedToArray(_$exec9, 4),
      channel = _$exec10[1],
      username = _$exec10[2],
      numberOfViewers = _$exec10[3];

  var isStopped = username === '-';

  /**
   * Host starts or stops a message.
   * @event Chat#HOSTTARGET
   * @mixes BaseMessage HostTargetMessage
   * @property {number} [numberOfViewers] Number of viewers
   * @see https://dev.twitch.tv/docs/irc/commands/#hosttarget-twitch-commands
   */
  return _extends({}, baseMessage, {
    channel: channel,
    username: username,
    event: (0, _toUpper3.default)(isStopped ? constants.NOTICE_MESSAGE_IDS.HOST_OFF : constants.NOTICE_MESSAGE_IDS.HOST_ON),
    numberOfViewers: (0, _isFinite3.default)((0, _toNumber3.default)(numberOfViewers)) ? parseInt(numberOfViewers, 10) : undefined,
    message: undefined
  });
};

var roomStateMessage = function roomStateMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  /**
   * When a user joins a channel or a room setting is changed.
   * @event Chat#ROOMSTATE
   * @mixes BaseMessage RoomStateMessage
   * @property {RoomStateTags} tags
   */


  return _extends({
    tags: tagParsers.roomState(tags)
  }, other);
};

var noticeMessage = function noticeMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  var event = (0, _toUpper3.default)(tags.msgId);

  switch (tags.msgId) {
    case constants.NOTICE_MESSAGE_IDS.ROOM_MODS:
      /**
       * NOTICE/ROOM_MODS message
       * @event Chat#NOTICE/ROOM_MODS
       * @mixes NoticeMessage NoticeMessage
       * @property {'ROOM_MODS'} event
       * @property {Array<string>} mods
       */
      return _extends({ event: event, tags: tags, mods: typeParsers.mods(other.message) }, other);
    default:
      /**
       * @event Chat#NOTICE
       * @mixes NoticeMessage
       * @property {string} event `msg-id` tag (snake uppercase)
       * @property {Object} tags
       * @see https://dev.twitch.tv/docs/irc/commands/#msg-id-tags-for-the-notice-commands-capability
       */

      /**
       * NOTICE message
       * @mixin NoticeMessage
       * @property {string} event `msg-id` tag (snake uppercase)
       * @property {Object} tags
       */
      return _extends({ event: event, tags: tags }, other);
  }
};

var userStateMessage = function userStateMessage(baseMessage) {
  var tags = baseMessage.tags,
      other = _objectWithoutProperties(baseMessage, ['tags']);

  /**
   * USERSTATE message
   * @mixin UserStateMessage
   * @mixes BaseMessage
   * @property {UserStateTags} tags
   */
  /**
   * When a user joins a channel or sends a PRIVMSG to a channel.
   * @event Chat#USERSTATE
   * @mixes UserStateMessage UserStateMessage
   */


  return _extends({
    tags: tagParsers.userState(tags)
  }, other, typeParsers.cheerEvent(tags.bits));
};

/**
 * When a user joins a channel or sends a PRIVMSG to a channel.
 * @event Chat#PRIVMSG
 * @mixes UserStateMessage PrivateMessage
 * @property {'CHEER'} [event]
 * @property {string} [event]
 * @property {number} [bits]
 */
var privateMessage = userStateMessage;

var userNoticeMessage = function userNoticeMessage(baseMessage) {
  var tags = tagParsers.userNotice(baseMessage.tags);

  switch (tags.msgId) {
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION:
      /**
       * On subscription (first month) to a channel.
       * @event Chat#USERNOTICE/SUBSCRIPTION
       * @mixes UserStateMessage UserNoticeSubscriptionMessage
       * @property {'SUBSCRIPTION'} event
       * @property {string} systemMessage
       * @property {string} months
       * @property {string} subPlan
       * @property {string} subPlanName
       */
      return _extends({}, baseMessage, {
        tags: tags,
        event: constants.EVENTS.SUBSCRIPTION,
        systemMessage: typeParsers.generalString(tags.systemMsg),
        months: tags.msgParamMonths,
        subPlan: tags.msgParamSubPlan,
        subPlanName: typeParsers.generalString(tags.msgParamSubPlanName)
      });
    case constants.USER_NOTICE_MESSAGE_IDS.RESUBSCRIPTION:
      /**
       * On resubscription (subsequent months) to a channel.
       * @event Chat#USERNOTICE/RESUBSCRIPTION
       * @mixes UserNoticeSubscriptionMessage UserNoticeResubscriptionMessage
       * @property {'RESUBSCRIPTION'} event
       */
      return _extends({}, baseMessage, {
        tags: tags,
        event: constants.EVENTS.RESUBSCRIPTION,
        systemMessage: typeParsers.generalString(tags.systemMsg),
        months: tags.msgParamMonths,
        subPlan: tags.msgParamSubPlan,
        subPlanName: typeParsers.generalString(tags.msgParamSubPlanName)
      });
    case constants.USER_NOTICE_MESSAGE_IDS.SUBSCRIPTION_GIFT:
      /**
       * On subscription gift to a channel.
       * @event Chat#USERNOTICE/SUBSCRIPTION_GIFT
       * @mixes UserStateMessage UserNoticeSubscriptionGiftMessage
       * @property {'SUBSCRIPTION_GIFT'} event
       * @property {string} systemMessage
       * @property {string} recipientDisplayName
       * @property {string} recipientId
       * @property {string} recipientUserName
       */
      return _extends({}, baseMessage, {
        tags: tags,
        event: constants.EVENTS.SUBSCRIPTION_GIFT,
        systemMessage: typeParsers.generalString(tags.systemMsg),
        recipientDisplayName: tags.msgParamRecipientDisplayName,
        recipientId: tags.msgParamRecipientId,
        recipientUserName: tags.msgParamRecipientName
      });
    case constants.USER_NOTICE_MESSAGE_IDS.RAID:
      /**
       * On channel raid.
       * @event Chat#USERNOTICE/RAID
       * @mixes UserStateMessage UserNoticeRaidMessage
       * @property {'RAID'} event
       * @property {string} systemMessage
       * @property {string} raiderDisplayName
       * @property {string} raiderUserName
       * @property {string} raiderViewerCount
       */
      return _extends({}, baseMessage, {
        tags: tags,
        event: constants.EVENTS.RAID,
        systemMessage: typeParsers.generalString(tags.systemMsg),
        raiderDisplayName: tags.msgParamDisplayName,
        raiderUserName: tags.msgParamLogin,
        raiderViewerCount: tags.msgParamViewerCount
      });
    case constants.USER_NOTICE_MESSAGE_IDS.RITUAL:
      /**
       * On channel ritual.
       * @event Chat#USERNOTICE/RITUAL
       * @mixes UserStateMessage UserNoticeRitualMessage
       * @property {'RITUAL'} event
       * @property {string} systemMessage
       * @property {string} ritualName
       */
      return _extends({}, baseMessage, {
        tags: tags,
        event: constants.EVENTS.RITUAL,
        systemMessage: typeParsers.generalString(tags.systemMsg),
        ritualName: tags.msgParamRitualName
      });
    default:
      return _extends({}, baseMessage, { tags: tags });
  }
};

exports.modeMessage = modeMessage;
exports.hostTargetMessage = hostTargetMessage;
exports.joinOrPartMessage = joinOrPartMessage;
exports.namesMessage = namesMessage;
exports.namesEndMessage = namesEndMessage;
exports.clearChatMessage = clearChatMessage;
exports.globalUserStateMessage = globalUserStateMessage;
exports.userStateMessage = userStateMessage;
exports.roomStateMessage = roomStateMessage;
exports.noticeMessage = noticeMessage;
exports.userNoticeMessage = userNoticeMessage;
exports.privateMessage = privateMessage;
exports.default = base;
//# sourceMappingURL=index.js.map